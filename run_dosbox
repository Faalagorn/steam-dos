#!/usr/bin/env python3

# pylint: disable=missing-docstring
# pylint: disable=fixme

import argparse
import os
import subprocess
import sys

import confgen
import midi

# pylint: disable=wildcard-import
from toolbox import *

from tweaks import TWEAKS_DB, tweak_command

STEAM_APP_ID = os.environ.get('SteamAppId')

PID_FILE = f'/tmp/steam_dos_{STEAM_APP_ID}'

MIDI_DISABLED = enabled_in_env('SD_NO_MIDI')


def wait_for_previous_process():
    if not STEAM_APP_ID:
        return
    pid = 0
    try:
        with open(PID_FILE, 'r') as pid_file:
            pid = int(pid_file.read())
    except FileNotFoundError:
        pass
    if pid and os.path.isfile(f'/proc/{pid}/cmdline'):
        print_err(f'run_dosbox: waiting for process {pid} to stop',
                  f'and delete file {PID_FILE}')
        subprocess.call(['inotifywait', '-e', 'delete', PID_FILE])


# FIXME rewrite this as __enter__, __exit__ to be used in 'with' statement
def create_pid_file():
    if not STEAM_APP_ID:
        return
    with open(PID_FILE, 'w') as pid_file:
        pid_file.write(str(os.getpid()))


def cleanup_pid_file():
    if not STEAM_APP_ID:
        return
    try:
        os.remove(PID_FILE)
    except FileNotFoundError:
        pass


def configure_midi():
    """Detect or run and configure MIDI synth."""
    if MIDI_DISABLED:
        # User decided to disable MIDI support.
        return
    if midi.detect_software_synthesiser(r'timidity|fluid'):
        # Synthesiser is already running (maybe as a service).
        # There's no reason to start our own.
        return

    # TODO assure soundfont exists
    # sfont = '/usr/share/soundfonts/timbres-of-heaven.sf2'
    sfont = '/usr/share/soundfonts/FluidR3_GM.sf2'
    if which('timidity'):
        midi.start_timidity(sfont)
    elif which('fluidsynth'):
        midi.start_fluidsynth(sfont)
    else:
        print_err('steam-dos: warn: no software MIDI synthesiser available')


def get_steam_dos_conf(args):
    name = confgen.uniq_conf_name(STEAM_APP_ID, args)
    if not os.path.isfile(name):
        print_err(f'run_dosbox: generating {name} based on {args}')
        confgen.create_conf_file(name, args)
    return name


def run_dosbox(args):
    create_pid_file()
    print_err('run_dosbox:', ['dosbox'] + args)
    subprocess.call(['dosbox'] + args)
    cleanup_pid_file()


def run(cmd_line, wait=False):

    if wait:
        wait_for_previous_process()

    _folder, exe = os.path.split(cmd_line[0]) if cmd_line else (None, '')

    if exe == 'iscriptevaluator.exe':
        print_err('run_dosbox: skipping Steam script:', cmd_line)

    elif STEAM_APP_ID in TWEAKS_DB:
        # If AppId is included in known tweaks, then modify command line
        # before handing it over to .conf generator:
        print_err(f'run_dosbox: tweaking command for app {STEAM_APP_ID}')
        name = get_steam_dos_conf(tweak_command(STEAM_APP_ID, cmd_line))
        configure_midi()
        run_dosbox(['-conf', name, '-conf', confgen.create_audio_conf()])

    elif STEAM_APP_ID and exe.lower() == 'dosbox.exe':
        # When dosbox with parameters is called, use them to
        # generate new .conf file.  When dosbox without parameters
        # is called, it implies: -conf dosbox.conf
        dosbox_args = cmd_line[1:] or ['-conf', 'dosbox.conf']
        name = get_steam_dos_conf(dosbox_args)
        configure_midi()
        run_dosbox(['-conf', name, '-conf', confgen.create_audio_conf()])

    elif STEAM_APP_ID and os.path.isfile('dosbox.conf'):
        # Executable is unrecognized, but at least there's a dosbox.conf
        # let's pretend it was passed to dropbox.exe:
        name = get_steam_dos_conf(['-conf', 'dosbox.conf'])
        run_dosbox(['-conf', name, '-conf', confgen.create_audio_conf()])

    else:
        print_err('run_dosbox: ignoring command:', cmd_line)


def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument('--get-native-path', action='store_true')
    group.add_argument('--get-compat-path', action='store_true')
    group.add_argument('--wait-before-run', action='store_true')
    group.add_argument('--get-current-step')
    args, run_cmd_line = parser.parse_known_args()

    if args.get_native_path:
        # FIXME convert single path: windows -> linux
        sys.exit(1)
    elif args.get_compat_path:
        # FIXME convert single path: linux -> windows
        sys.exit(1)
    elif args.get_current_step:
        # Steam sometimes ivokes this even when it's not defined in
        # toolmanifestâ€¦
        sys.exit(1)
    else:
        run(run_cmd_line, wait=args.wait_before_run)


if __name__ == "__main__":
    main()
