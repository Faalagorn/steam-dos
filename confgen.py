#!/usr/bin/env python3

"""
DOSBox configuration file generator.
"""

import argparse
import configparser
import hashlib
import os
import pathlib

import midi

from toolbox import print_err

COMMENT_SECTION = """
# Generated by steam-dos
# Based on args to Windows version of DOSBox:
# {}

""".lstrip()

SDL_SECTION = """
[sdl]
fullscreen=true
fullresolution=desktop
output=opengl
autolock=false
waitonerror=true

""".lstrip()

SBLASTER_SECTION = """
[sblaster]
sbtype=sb16
sbbase={base}
irq={irq}
dma={dma}
hdma={hdma}

""".lstrip()

SBLASTER_INFO = """
Digital Sound: Sound Blaster 16
    Base Port: {base}
          IRQ: {irq}
          DMA: {dma}
""".strip()

MIDI_SECTION = """
[midi]
mpu401=intelligent
mididevice=default
midiconfig={port}

""".lstrip()

# Port 330 is hard-coded in DOSBox
MIDI_INFO = """
        Music: General MIDI (MPU-401 compatible)
         Port: 330
"""[1:]

MIDI_INFO_NA = """
        Music: No MIDI synthesiser found
"""[1:]


class FileTree:
    """Provide access to a file tree using Windows paths."""

    def __init__(self, root):
        self.root = root
        self.cwd = root

    def get_posix_path(self, path):
        """Return real file referenced by case-insensitive Windows path."""
        return to_posix_path(self.root, path)

    def getcwd(self):
        """Return posix path representing current working directory."""
        return self.cwd  # TODO implement


class DosboxConfiguration(dict):

    """Class representing DOSBox configuration.

    Autoexec section represents commands from default .conf files,
    files referenced by -conf argument, commands injected with -c argument
    and commands usually generated by DOSBox itself.

    Other sections of raw configuration represent relevant sections
    found in configuration files.  Values inside sections override
    values seen in previous configuration files.
    """

    def __init__(self, *, pfx='.', commands=[], conf_files=[], exe=None):
        assert commands or conf_files or exe
        dict.__init__(self)
        self['autoexec'] = []
        self.raw_autoexec = self['autoexec']
        self.file_tree = FileTree(pfx)

        for win_path in (conf_files or self.__get_default_conf__()):
            path = self.file_tree.get_posix_path(win_path)
            conf = parse_dosbox_config(path)
            if conf.has_section('autoexec'):
                self.raw_autoexec.extend(line for line in conf['autoexec'])

        self.raw_autoexec.extend(cmd for cmd in commands)

        if exe:
            posix_path = self.file_tree.get_posix_path(exe)
            path, file = os.path.split(posix_path)
            self.raw_autoexec.append(f'mount C {path or "."}')
            self.raw_autoexec.append('C:')
            self.raw_autoexec.append(file)

    def __get_default_conf__(self):
        path = self.file_tree.get_posix_path('dosbox.conf')
        if path and os.path.isfile(path):
            return [path]
        return []

    def sections(self):
        """Return a list of section names."""
        return list(self.keys())


def uniq_conf_name(app_id, args):
    """Return unique .conf file name for given SteamAppId and arguments."""
    uid_line = app_id + ''.join(args)
    uid = hashlib.sha1(uid_line.encode('utf-8')).hexdigest()[:6]
    return f'steam_dos_{app_id}_{uid}.conf'


def parse_dosbox_config(conf_file):
    """Parse DOSBox configuration file."""
    if conf_file is None:
        return None
    config = configparser.ConfigParser(allow_no_value=True, delimiters='=')
    config.optionxform = str
    config.read(conf_file)
    return config


def convert_autoexec_section(config):
    """Return iterator over lines in autoexec section.

    Necessary paths will be converted to posix paths."""
    dos_drives = {}
    active_path = '.'
    for line in config['autoexec']:
        words = line.split()  # TODO quoting, maybe proper parser
        cmd = words[0].lower()
        if cmd == 'exit':
            continue
        if cmd == 'mount':
            drive = words[1][0].upper()
            path = to_posix_path(active_path, words[2]) or '.'
            dos_drives[drive] = path
            yield ' '.join(['mount', drive, path] + words[3:])
            continue
        if len(cmd) == 2 and cmd[0].isalpha() and cmd[1] == ':':
            drive = cmd[0].upper()
            active_path = dos_drives[drive]
            yield f'{drive}:'
            continue
        yield line
    yield 'exit'  # add 'exit' for games, that passed it through -c param


def parse_dosbox_arguments(args):
    """Parse subset of DOSBox command line arguments."""
    parser = argparse.ArgumentParser()
    parser.add_argument('-conf', action='append')
    parser.add_argument('-c', action='append')
    parser.add_argument('-noconsole', action='store_true')
    parser.add_argument('-fullscreen', action='store_true')
    parser.add_argument('-exit', action='store_true')
    parser.add_argument('file', nargs='?')
    return parser.parse_args(args)


def create_conf_file(name, dosbox_args):
    """Create DOSBox configuration file.

    Different sections are chosen either by this module, copied from
    existing .conf files, generated based on '-c' DOSBox argument or
    generated from a file pointed to be run.
    """
    assert name

    args = parse_dosbox_arguments(dosbox_args)
    exe_file = to_posix_path('.', args.file) if args.file else ''
    orig_conf_file = to_posix_path('.', args.conf[0]) if args.conf else ''
    fallback_conf_file = to_posix_path('.', 'dosbox.conf')
    dos_commands = args.c if args.c else []

    assert exe_file or orig_conf_file

    original_config = parse_dosbox_config(orig_conf_file)
    fallback_config = parse_dosbox_config(fallback_conf_file)

    with open(name, 'w') as conf_file:
        conf_file.write(COMMENT_SECTION.format(dosbox_args))
        conf_file.write(SDL_SECTION.format(dosbox_args))

        # TODO remove code duplication from fallback_config

        if original_config and original_config.has_section('mixer'):
            conf_file.write(f'# Section copied from {orig_conf_file}\n')
            conf_file.write('[mixer]\n')
            for key, val in original_config['mixer'].items():
                conf_file.write(f'{key}={val}\n')
            conf_file.write('\n')
        elif fallback_config and fallback_config.has_section('mixer'):
            conf_file.write(f'# Section copied from {fallback_conf_file}\n')
            conf_file.write('[mixer]\n')
            for key, val in fallback_config['mixer'].items():
                conf_file.write(f'{key}={val}\n')
            conf_file.write('\n')

        if dos_commands:
            conf_file.write(f'# Section forced through -c arguments\n')
            conf_file.write('[autoexec]\n')
            for line in dos_commands:
                conf_file.write(line + '\n')
            conf_file.write('exit\n')
        elif exe_file:
            conf_file.write(f'# Section generated for {exe_file}\n')
            conf_file.write('[autoexec]\n')
            folder, exe = os.path.split(exe_file)
            conf_file.write(f'mount C {folder}\n')
            conf_file.write('C:\n')
            conf_file.write(f'{exe}\n')
            conf_file.write('exit\n')
        else:
            conf_file.write(f'# Section adapted from {orig_conf_file}\n')
            conf_file.write('[autoexec]\n')
            for line in convert_autoexec_section(original_config):
                conf_file.write(line + '\n')


def create_audio_conf():
    """Create DOSBox audio configuration."""
    name = 'steam_dos_audio.conf'

    mport = midi.detect_software_synthesiser(r'timidity|fluid')
    if mport:
        print_err(f'steam-dos: Detected {mport.name} on {mport.addr}')

    with open(name, 'w') as audio:
        audio.write('# Generated by steam-dos\n')
        audio.write('# This file is re-created on every run\n')
        audio.write('\n')
        base, irq, dma, hdma = 220, 7, 1, 5  # DOSBox defaults
        print_err('steam-dos: Setting up DOSBox audio:')
        print_err(SBLASTER_INFO.format(base=base, irq=irq, dma=dma))
        audio.write(SBLASTER_SECTION.format(base=base, irq=irq,
                                            dma=dma, hdma=hdma))
        if mport:
            print_err(MIDI_INFO)
            audio.write(MIDI_SECTION.format(port=mport.addr))
        else:
            print_err(MIDI_INFO_NA)
    return name


def to_posix_path(prefix, windows_path_str):
    """Convert a string representing case-insensitive path to a string
    representing path to existing file.
    """
    win_path = pathlib.PureWindowsPath(prefix + '\\' + windows_path_str)
    posix_parts = to_posix_parts(win_path.parts)
    if posix_parts is None:
        return None
    if posix_parts == ():
        return ''
    return os.path.join(*posix_parts)


def guess(part):
    """Generate all the possible capitalizations of given string,
    starting with the most probable ones.
    """
    yield part
    yield part.upper()
    yield part.lower()
    yield part.capitalize()

    def switch_cases(txt):
        if not txt:
            return ['']
        letter = txt[0]
        rest = switch_cases(txt[1:])
        return [letter.upper() + suffix for suffix in rest] + \
               [letter.lower() + suffix for suffix in rest]

    for candidate in switch_cases(part):
        yield candidate


def to_posix_parts(parts):
    """Return posix path representing existing file referenced in
    case-insensitive path passed as tuple.

    Works with assumption, that existing file is unique.
    """
    # TODO rewrite this in more time-effective manner for worst case scenario.
    if parts is None:
        return None
    if parts == ():
        return parts
    prefix_parts, last_part = parts[:-1], parts[-1]
    prefix = to_posix_parts(prefix_parts)
    if prefix is None:
        return None
    for case_sensitive_part in guess(last_part):
        case_sensitive_parts = prefix + (case_sensitive_part,)
        if os.path.exists(os.path.join(*case_sensitive_parts)):
            return case_sensitive_parts
    return None
