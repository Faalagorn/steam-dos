#!/usr/bin/env python3

# pylint: disable=fixme

"""
Module documentation
"""

import hashlib
import os
import pathlib


def uniq_conf_name(app_id, args):
    """Return unique .conf file for given SteamAppId and dosbox args."""
    uid_line = app_id + ''.join(args)
    uid = hashlib.sha1(uid_line.encode('utf-8')).hexdigest()[:6]
    return f'steam_dos_{app_id}_{uid}.conf'


def create_conf_file(name, dosbox_args):
    """FIXME doc"""
    assert name
    with open(name, 'w') as conf_file:
        conf_file.write('# generated by steam-dos\n')
        conf_file.write('# based on args to Windows version of dosbox:\n')
        conf_file.write(f'# {dosbox_args}\n')
        conf_file.write('\n')
        conf_file.write('[sdl]\n')
        conf_file.write('fullscreen=true\n')
        conf_file.write('fullresolution=desktop\n')
        conf_file.write('output=opengl\n')
        conf_file.write('autolock=false\n')
        conf_file.write('waitonerror=true\n')


def to_posix_path(windows_path_str):
    """Convert a string representing case-insensitive path to a string
    representing path to existing file.
    """
    win_path = pathlib.PureWindowsPath(windows_path_str)
    posix_parts = to_posix_parts(win_path.parts)
    if posix_parts is None:
        return None
    if posix_parts == ():
        return ''
    return os.path.join(*posix_parts)


def guess(part):
    """Generate all the possible capitalizations of given string,
    starting with the most probable ones.
    """
    yield part
    yield part.upper()
    yield part.lower()
    yield part.capitalize()

    def switch_cases(txt):
        if not txt:
            return ['']
        letter = txt[0]
        rest = switch_cases(txt[1:])
        return [letter.upper() + suffix for suffix in rest] + \
               [letter.lower() + suffix for suffix in rest]

    for candidate in switch_cases(part):
        yield candidate


def to_posix_parts(parts):
    """Return posix path representing existing file referenced in
    case-insensitive path passed as tuple.

    Works with assumption, that existing file is unique.
    """
    # FIXME rewrite this in more time-effective manner for worst case scenario.
    if parts is None:
        return None
    if parts == ():
        return parts
    prefix_parts, last_part = parts[:-1], parts[-1]
    prefix = to_posix_parts(prefix_parts)
    if prefix is None:
        return None
    for case_sensitive_part in guess(last_part):
        case_sensitive_parts = prefix + (case_sensitive_part,)
        if os.path.exists(os.path.join(*case_sensitive_parts)):
            return case_sensitive_parts
    return None
